{"version":3,"file":"vue-types.js","sources":["../src/utils.ts","../src/validators/native.ts","../src/validators/custom.ts","../src/validators/oneof.ts","../src/validators/oneoftype.ts","../src/validators/arrayof.ts","../src/validators/instanceof.ts","../src/validators/objectof.ts","../src/validators/shape.ts","../src/index.ts","../src/sensibles.ts"],"sourcesContent":["import _isPlainObject from 'is-plain-object'\nimport Vue from 'vue'\nimport { PropOptions } from 'vue'\nimport {\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueProp,\n  InferType,\n} from '../types/vue-types'\n\nconst ObjProto = Object.prototype\nconst toString = ObjProto.toString\nexport const hasOwn = ObjProto.hasOwnProperty\n\nconst FN_MATCH_REGEXP = /^\\s*function (\\w+)/\n\n// https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177\nexport function getType(\n  fn: VueProp<any> | (() => any) | (new (...args: any[]) => any),\n): string {\n  const type = (fn && (fn as VueProp<any>).type) || fn\n  if (type) {\n    const match = type.toString().match(FN_MATCH_REGEXP)\n    return match ? match[1] : ''\n  }\n  return ''\n}\n\nexport function getNativeType(value: any): string {\n  if (value === null || value === undefined) return ''\n  const match = value.constructor.toString().match(FN_MATCH_REGEXP)\n  return match ? match[1] : ''\n}\n\ntype PlainObject = { [key: string]: any }\nexport const isPlainObject = _isPlainObject as (obj: any) => obj is PlainObject\n\n/**\n * No-op function\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\nlet warn: (msg: string) => void = noop\n\nif (process.env.NODE_ENV !== 'production') {\n  const hasConsole = typeof console !== 'undefined'\n  warn = hasConsole\n    ? function warn(msg) {\n        // eslint-disable-next-line no-console\n        Vue.config.silent === false && console.warn(`[VueTypes warn]: ${msg}`)\n      }\n    : noop\n}\n\nexport { warn }\n\n/**\n * Checks for a own property in an object\n *\n * @param {object} obj - Object\n * @param {string} prop - Property to check\n */\nexport const has = <T extends object, U extends keyof T>(obj: T, prop: U) =>\n  hasOwn.call(obj, prop)\n\n/**\n * Determines whether the passed value is an integer. Uses `Number.isInteger` if available\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @param {*} value - The value to be tested for being an integer.\n * @returns {boolean}\n */\nexport const isInteger =\n  Number.isInteger ||\n  function isInteger(value: unknown): value is number {\n    return (\n      typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    )\n  }\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @param {*} value - The value to be tested for being an array.\n * @returns {boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function isArray(value): value is any[] {\n    return toString.call(value) === '[object Array]'\n  }\n\n/**\n * Checks if a value is a function\n *\n * @param {any} value - Value to check\n * @returns {boolean}\n */\nexport const isFunction = (value: unknown): value is Function =>\n  toString.call(value) === '[object Function]'\n\nexport const isVueTypeDef = <T>(\n  value: any,\n): value is VueTypeDef<T> | VueTypeValidableDef<T> =>\n  isPlainObject(value) && has(value, '_vueTypes_name')\n\nexport const isComplexType = <T>(value: any): value is VueProp<T> =>\n  isPlainObject(value) &&\n  (has(value, 'type') ||\n    ['_vueTypes_name', 'validator', 'default', 'required'].some((k) =>\n      has(value, k),\n    ))\n\nexport interface WrappedFn {\n  (...args: any[]): any\n  __original: (...args: any[]) => any\n}\n\nexport function bindTo(fn: (...args: any[]) => any, ctx: any): WrappedFn {\n  return Object.defineProperty(fn.bind(ctx), '__original', {\n    value: fn,\n  })\n}\n\nexport function unwrap<T extends WrappedFn | Function>(fn: T) {\n  return (fn as WrappedFn).__original ?? fn\n}\n\n/**\n * Validates a given value against a prop type object\n *\n * @param {Object|*} type - Type to use for validation. Either a type object or a constructor\n * @param {*} value - Value to check\n * @param {boolean} silent - Silence warnings\n */\nexport function validateType<T, U>(type: T, value: U, silent = false) {\n  let typeToCheck: { [key: string]: any }\n  let valid = true\n  let expectedType = ''\n  if (!isPlainObject(type)) {\n    typeToCheck = { type }\n  } else {\n    typeToCheck = type\n  }\n  const namePrefix = isVueTypeDef(typeToCheck)\n    ? typeToCheck._vueTypes_name + ' - '\n    : ''\n\n  if (isComplexType(typeToCheck) && typeToCheck.type !== null) {\n    if (typeToCheck.type === undefined) {\n      return valid\n    }\n    if (!typeToCheck.required && value === undefined) {\n      return valid\n    }\n    if (typeToCheck.type === undefined) {\n      expectedType = 'any'\n    } else if (isArray(typeToCheck.type)) {\n      valid = typeToCheck.type.some((type: any) =>\n        validateType(type, value, true),\n      )\n      expectedType = typeToCheck.type\n        .map((type: any) => getType(type))\n        .join(' or ')\n    } else {\n      expectedType = getType(typeToCheck)\n\n      if (expectedType === 'Array') {\n        valid = isArray(value)\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value)\n      } else if (\n        expectedType === 'String' ||\n        expectedType === 'Number' ||\n        expectedType === 'Boolean' ||\n        expectedType === 'Function'\n      ) {\n        valid = getNativeType(value) === expectedType\n      } else {\n        valid = value instanceof typeToCheck.type\n      }\n    }\n  }\n\n  if (!valid) {\n    silent === false &&\n      warn(`${namePrefix}value \"${value}\" should be of type \"${expectedType}\"`)\n    return false\n  }\n\n  if (has(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {\n    // swallow warn\n    let oldWarn: any\n    if (silent) {\n      oldWarn = warn\n      warn = noop\n    }\n\n    valid = typeToCheck.validator(value)\n    oldWarn && (warn = oldWarn)\n\n    if (!valid && silent === false)\n      warn(`${namePrefix}custom validation failed`)\n    return valid\n  }\n  return valid\n}\n\n/**\n * Adds `isRequired` and `def` modifiers to an object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toType<T = any>(name: string, obj: PropOptions<T>) {\n  const type: VueTypeDef<T> = Object.defineProperties(obj, {\n    // eslint-disable-next-line @typescript-eslint/camelcase\n    _vueTypes_name: {\n      value: name,\n      writable: true,\n    },\n    isRequired: {\n      get() {\n        this.required = true\n        return this\n      },\n    },\n    def: {\n      value(def?: any) {\n        if (def === undefined && !this.default) {\n          return this\n        }\n        if (!isFunction(def) && !validateType(this, def)) {\n          warn(`${this._vueTypes_name} - invalid default value: \"${def}\"`)\n          return this\n        }\n        if (isArray(def)) {\n          this.default = () => [...def]\n        } else if (isPlainObject(def)) {\n          this.default = () => Object.assign({}, def)\n        } else {\n          this.default = def\n        }\n        return this\n      },\n    },\n  })\n\n  const { validator } = type\n  if (isFunction(validator)) {\n    type.validator = bindTo(validator, type)\n  }\n\n  return type\n}\n\n/**\n * Like `toType` but also adds the `validate()` method to the type object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toValidableType<T = any>(name: string, obj: PropOptions<T>) {\n  const type = toType<T>(name, obj)\n  return Object.defineProperty(type, 'validate', {\n    value(fn: (value: T) => boolean) {\n      this.validator = bindTo(fn, this)\n      return this\n    },\n  }) as VueTypeValidableDef<T>\n}\n\nexport function clone<T extends object>(type: T): T {\n  const descriptors = {} as { [P in keyof T]: any }\n  Object.getOwnPropertyNames(type).forEach((key) => {\n    descriptors[key as keyof T] = Object.getOwnPropertyDescriptor(type, key)\n  })\n  return Object.defineProperties({}, descriptors)\n}\n\nexport function fromType<T extends VueTypeDef<any>, U = InferType<T>>(\n  name: string,\n  source: T,\n  props = {} as PropOptions<U>,\n): VueTypeDef<U> {\n  const { validator, ...rest } = props\n\n  // 1. create an exact copy of the source type\n  const copy = clone<VueTypeDef<U>>(source)\n\n  // 2. give it a new name\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  copy._vueTypes_name = name\n\n  // 3. compose the validator function\n  // with the one on the source (if present)\n  // and ensure it is bound to the copy\n  if (isFunction(validator)) {\n    let { validator: prevValidator } = copy\n\n    if (prevValidator) {\n      prevValidator = unwrap(prevValidator)\n    }\n\n    copy.validator = bindTo(\n      prevValidator\n        ? function (this: VueTypeDef<U>, value: any) {\n            return (\n              prevValidator.call(this, value) && validator.call(this, value)\n            )\n          }\n        : validator,\n      copy,\n    )\n  }\n  // 4. overwrite the rest, if present\n  return Object.assign(copy, rest)\n}\n","import { toType, toValidableType, isInteger } from '../utils'\n\nexport const any = () => toValidableType('any', {})\n\nexport const func = <T extends Function>() =>\n  toValidableType<T>('function', {\n    type: Function,\n  })\n\nexport const bool = () =>\n  toValidableType('boolean', {\n    type: Boolean,\n  })\n\nexport const string = () =>\n  toValidableType('string', {\n    type: String,\n  })\n\nexport const number = () =>\n  toValidableType('number', {\n    type: Number,\n  })\n\nexport const array = <T>() =>\n  toValidableType<T[]>('array', {\n    type: Array,\n  })\n\nexport const object = <T extends { [key: string]: any }>() =>\n  toValidableType<T>('object', {\n    type: Object,\n  })\n\nexport const integer = () =>\n  toType('integer', {\n    type: Number,\n    validator(value) {\n      return isInteger(value)\n    },\n  })\n\nexport const symbol = () =>\n  toValidableType<symbol>('symbol', {\n    validator(value) {\n      return typeof value === 'symbol'\n    },\n  })\n","import { toType, warn } from '../utils'\nimport { ValidatorFunction, VueTypeDef } from '../../types/vue-types'\n\nexport default function custom<T>(\n  validatorFn: ValidatorFunction<T>,\n  warnMsg = 'custom validation failed',\n) {\n  if (typeof validatorFn !== 'function') {\n    throw new TypeError(\n      '[VueTypes error]: You must provide a function as argument',\n    )\n  }\n\n  return toType<T>(validatorFn.name || '<<anonymous function>>', {\n    validator(this: VueTypeDef<T>, value) {\n      const valid = validatorFn(value)\n      if (!valid) warn(`${this._vueTypes_name} - ${warnMsg}`)\n      return valid\n    },\n  })\n}\n","import { Prop } from '../../types/vue-types'\nimport { toType, warn, isArray } from '../utils'\n\nexport default function oneOf<T extends readonly any[], U = T[number]>(arr: T) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument',\n    )\n  }\n  const msg = `oneOf - value should be one of \"${arr.join('\", \"')}\"`\n  const allowedTypes = arr.reduce((ret, v) => {\n    if (v !== null && v !== undefined) {\n      const constr = (v as any).constructor\n      ret.indexOf(constr) === -1 && ret.push(constr)\n    }\n    return ret\n  }, [] as Prop<U>[])\n\n  return toType<U>('oneOf', {\n    type: allowedTypes.length > 0 ? allowedTypes : undefined,\n    validator(value) {\n      const valid = arr.indexOf(value) !== -1\n      if (!valid) warn(msg)\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, InferType } from '../../types/vue-types'\nimport {\n  isArray,\n  isComplexType,\n  isVueTypeDef,\n  isFunction,\n  getType,\n  toType,\n  validateType,\n  warn,\n} from '../utils'\n\nexport default function oneOfType<\n  U extends VueProp<any> | Prop<any>,\n  V = InferType<U>\n>(arr: U[]) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument',\n    )\n  }\n\n  let hasCustomValidators = false\n\n  let nativeChecks: Prop<V>[] = []\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const type = arr[i]\n    if (isComplexType<V>(type)) {\n      if (\n        isVueTypeDef<V>(type) &&\n        type._vueTypes_name === 'oneOf' &&\n        type.type\n      ) {\n        nativeChecks = nativeChecks.concat(type.type)\n        continue\n      }\n      if (isFunction(type.validator)) {\n        hasCustomValidators = true\n        continue\n      }\n      if (type.type) {\n        nativeChecks = nativeChecks.concat(type.type)\n        continue\n      }\n    }\n    nativeChecks.push(type as Prop<V>)\n  }\n\n  if (!hasCustomValidators) {\n    // we got just native objects (ie: Array, Object)\n    // delegate to Vue native prop check\n    return toType<V>('oneOfType', {\n      type: nativeChecks,\n    })\n  }\n\n  const typesStr = arr\n    .reduce<string[]>(\n      (ret, type) =>\n        ret.concat(\n          isComplexType<V>(type) && isArray((type as any).type)\n            ? (type as any).type.map(getType)\n            : getType(type),\n        ),\n      [],\n    )\n    .join('\", \"')\n\n  return toType<V>('oneOfType', {\n    validator(value) {\n      const valid = arr.some((type) => {\n        if (isVueTypeDef(type) && type._vueTypes_name === 'oneOf') {\n          return type.type ? validateType(type.type, value, true) : true\n        }\n        return validateType(type, value, true)\n      })\n      if (!valid) warn(`oneOfType - value type should be one of \"${typesStr}\"`)\n      return valid\n    },\n  })\n}\n","import { Prop, VueProp, InferType } from '../../types/vue-types'\nimport { getType, toType, validateType, warn } from '../utils'\n\nexport default function arrayOf<\n  T extends VueProp<any> | Prop<any>,\n  U = InferType<T>\n>(type: T) {\n  return toType<U[]>('arrayOf', {\n    type: Array,\n    validator(values) {\n      const valid = values.every((value) => validateType(type, value))\n      if (!valid) warn(`arrayOf - value must be an array of \"${getType(type)}\"`)\n      return valid\n    },\n  })\n}\n","import { toType } from '../utils'\nimport { Constructor } from '../../types/vue-types'\n\nexport default function instanceOf<C extends Constructor>(\n  instanceConstructor: C,\n) {\n  return toType<InstanceType<C>>('instanceOf', {\n    type: instanceConstructor,\n  })\n}\n","import { Prop, VueProp, InferType } from '../../types/vue-types'\nimport { getType, toType, validateType, warn } from '../utils'\n\nexport default function objectOf<\n  T extends VueProp<any> | Prop<any>,\n  U = InferType<T>\n>(type: T) {\n  return toType<{ [key: string]: U }>('objectOf', {\n    type: Object,\n    validator(obj) {\n      const valid = Object.keys(obj).every((key) =>\n        validateType(type, obj[key]),\n      )\n      if (!valid)\n        warn(`objectOf - value must be an object of \"${getType(type)}\"`)\n      return valid\n    },\n  })\n}\n","import {\n  Prop,\n  VueProp,\n  VueTypeShape,\n  VueTypeLooseShape,\n} from '../../types/vue-types'\nimport { toType, validateType, warn, isPlainObject } from '../utils'\n\nexport default function shape<T extends object>(\n  obj: { [K in keyof T]?: Prop<T[K]> | VueProp<T[K]> },\n): VueTypeShape<T> {\n  const keys = Object.keys(obj)\n  const requiredKeys = keys.filter((key) => !!(obj as any)[key]?.required)\n\n  const type = toType('shape', {\n    type: Object,\n    validator(this: VueTypeShape<T> | VueTypeLooseShape<T>, value) {\n      if (!isPlainObject(value)) {\n        return false\n      }\n      const valueKeys = Object.keys(value)\n\n      // check for required keys (if any)\n      if (\n        requiredKeys.length > 0 &&\n        requiredKeys.some((req) => valueKeys.indexOf(req) === -1)\n      ) {\n        warn(\n          `shape - at least one of required properties \"${requiredKeys.join(\n            '\", \"',\n          )}\" is not present`,\n        )\n        return false\n      }\n\n      return valueKeys.every((key) => {\n        if (keys.indexOf(key) === -1) {\n          if ((this as VueTypeLooseShape<T>)._vueTypes_isLoose === true)\n            return true\n          warn(`shape - object is missing \"${key}\" property`)\n          return false\n        }\n        const type = (obj as any)[key]\n        return validateType(type, value[key])\n      })\n    },\n  }) as VueTypeShape<T>\n\n  Object.defineProperty(type, '_vueTypes_isLoose', {\n    writable: true,\n    value: false,\n  })\n\n  Object.defineProperty(type, 'loose', {\n    get() {\n      // eslint-disable-next-line @typescript-eslint/camelcase\n      this._vueTypes_isLoose = true\n      return this\n    },\n  })\n\n  return type\n}\n","import {\n  toType,\n  toValidableType,\n  validateType,\n  isArray,\n  isVueTypeDef,\n  has,\n  fromType,\n} from './utils'\n\nimport {\n  VueTypesDefaults,\n  ExtendProps,\n  VueTypeDef,\n  VueTypeValidableDef,\n} from '../types/vue-types'\nimport { typeDefaults } from './sensibles'\nimport { PropOptions } from 'vue'\nimport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n} from './validators/native'\nimport custom from './validators/custom'\nimport oneOf from './validators/oneof'\nimport oneOfType from './validators/oneoftype'\nimport arrayOf from './validators/arrayof'\nimport instanceOf from './validators/instanceof'\nimport objectOf from './validators/objectof'\nimport shape from './validators/shape'\n\nexport default class VueTypes {\n  static defaults: Partial<VueTypesDefaults> = typeDefaults()\n\n  static get sensibleDefaults() {\n    return { ...this.defaults }\n  }\n\n  static set sensibleDefaults(v: boolean | Partial<VueTypesDefaults>) {\n    if (v === false) {\n      this.defaults = {}\n      return\n    }\n    if (v === true) {\n      this.defaults = typeDefaults()\n      return\n    }\n    this.defaults = { ...v }\n  }\n\n  static get any() {\n    return any()\n  }\n  static get func() {\n    return func().def(this.defaults.func)\n  }\n  static get bool() {\n    return bool().def(this.defaults.bool)\n  }\n  static get string() {\n    return string().def(this.defaults.string)\n  }\n  static get number() {\n    return number().def(this.defaults.number)\n  }\n  static get array() {\n    return array().def(this.defaults.array)\n  }\n  static get object() {\n    return object().def(this.defaults.object)\n  }\n  static get integer() {\n    return integer().def(this.defaults.integer)\n  }\n  static get symbol() {\n    return symbol()\n  }\n\n  static readonly custom = custom\n  static readonly oneOf = oneOf\n  static readonly instanceOf = instanceOf\n  static readonly oneOfType = oneOfType\n  static readonly arrayOf = arrayOf\n  static readonly objectOf = objectOf\n  static readonly shape = shape\n\n  static extend<T extends typeof VueTypes>(\n    props: ExtendProps | ExtendProps[],\n  ): T {\n    if (isArray(props)) {\n      props.forEach((p) => this.extend(p))\n      return this as any\n    }\n\n    const { name, validate = false, getter = false, ...opts } = props\n\n    if (has(this, name as any)) {\n      throw new TypeError(`[VueTypes error]: Type \"${name}\" already defined`)\n    }\n\n    const { type } = opts\n    if (isVueTypeDef(type)) {\n      // we are using as base type a vue-type object\n\n      // detach the original type\n      // we are going to inherit the parent data.\n      delete opts.type\n\n      if (getter) {\n        return Object.defineProperty(this, name, {\n          get: () => fromType(name, type, opts as Omit<ExtendProps, 'type'>),\n        })\n      }\n      return Object.defineProperty(this, name, {\n        value(...args: unknown[]) {\n          const t = fromType(name, type, opts as Omit<ExtendProps, 'type'>)\n          if (t.validator) {\n            t.validator = t.validator.bind(t, ...args)\n          }\n          return t\n        },\n      })\n    }\n\n    let descriptor: PropertyDescriptor\n    if (getter) {\n      descriptor = {\n        get() {\n          const typeOptions = Object.assign({}, opts as PropOptions<T>)\n          if (validate) {\n            return toValidableType<T>(name, typeOptions)\n          }\n          return toType<T>(name, typeOptions)\n        },\n        enumerable: true,\n      }\n    } else {\n      descriptor = {\n        value(...args: T[]) {\n          const typeOptions = Object.assign({}, opts as PropOptions<T>)\n          let ret: VueTypeDef<T>\n          if (validate) {\n            ret = toValidableType<T>(name, typeOptions)\n          } else {\n            ret = toType<T>(name, typeOptions)\n          }\n\n          if (typeOptions.validator) {\n            ret.validator = typeOptions.validator.bind(ret, ...args)\n          }\n          return ret\n        },\n        enumerable: true,\n      }\n    }\n\n    return Object.defineProperty(this, name, descriptor)\n  }\n\n  static utils = {\n    validate<T, U>(value: T, type: U) {\n      return validateType<U, T>(type, value, true)\n    },\n    toType<T = unknown>(\n      name: string,\n      obj: PropOptions<T>,\n      validable = false,\n    ): VueTypeDef<T> | VueTypeValidableDef<T> {\n      return validable ? toValidableType<T>(name, obj) : toType<T>(name, obj)\n    },\n  }\n}\n\nfunction createTypes(defs: Partial<VueTypesDefaults> = typeDefaults()) {\n  return class extends VueTypes {\n    static defaults: Partial<VueTypesDefaults> = { ...defs }\n\n    static get sensibleDefaults() {\n      return { ...this.defaults }\n    }\n\n    static set sensibleDefaults(v: boolean | Partial<VueTypesDefaults>) {\n      if (v === false) {\n        this.defaults = {}\n        return\n      }\n      if (v === true) {\n        this.defaults = { ...defs }\n        return\n      }\n      this.defaults = { ...v }\n    }\n  }\n}\n\nexport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n  custom,\n  oneOf,\n  oneOfType,\n  arrayOf,\n  instanceOf,\n  objectOf,\n  shape,\n  createTypes,\n  toType,\n  toValidableType,\n  validateType,\n  fromType,\n}\n","import { VueTypesDefaults } from '../types/vue-types'\n\nexport const typeDefaults = (): VueTypesDefaults => ({\n  func: () => undefined,\n  bool: true,\n  string: '',\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0,\n})\n"],"names":["ObjProto","Object","prototype","toString","hasOwn","hasOwnProperty","FN_MATCH_REGEXP","getType","fn","type","match","isPlainObject","_isPlainObject","noop","warn","process","env","NODE_ENV","hasConsole","console","msg","Vue","config","silent","has","obj","prop","call","isInteger","Number","value","isFinite","Math","floor","isArray","Array","isFunction","isVueTypeDef","isComplexType","some","k","bindTo","ctx","defineProperty","bind","validateType","typeToCheck","valid","expectedType","oldWarn","namePrefix","_vueTypes_name","undefined","required","map","join","constructor","getNativeType","validator","toType","name","defineProperties","writable","isRequired","get","this","def","default","assign","toValidableType","fromType","source","props","descriptors","rest","copy","getOwnPropertyNames","forEach","key","getOwnPropertyDescriptor","prevValidator","__original","any","func","Function","bool","Boolean","string","String","number","array","object","integer","symbol","custom","validatorFn","warnMsg","TypeError","oneOf","arr","allowedTypes","reduce","ret","v","constr","indexOf","push","length","oneOfType","hasCustomValidators","nativeChecks","i","concat","typesStr","arrayOf","values","every","instanceOf","instanceConstructor","objectOf","keys","shape","requiredKeys","filter","_obj$key","valueKeys","req","_this","_vueTypes_isLoose","VueTypes","extend","p","validate","getter","opts","descriptor","t","typeOptions","enumerable","defaults","validable","defs"],"mappings":"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"}