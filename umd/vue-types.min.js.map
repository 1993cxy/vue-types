{"version":3,"file":"vue-types.min.js","sources":["../node_modules/is-plain-object/index.js","../node_modules/is-plain-object/node_modules/isobject/index.js","../src/utils.js","../src/sensibles.js","../src/index.js"],"sourcesContent":["/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","import isPlainObject from 'is-plain-object'\nimport Vue from 'vue'\n\nconst ObjProto = Object.prototype\nconst toString = ObjProto.toString\nexport const hasOwn = ObjProto.hasOwnProperty\n\nconst FN_MATCH_REGEXP = /^\\s*function (\\w+)/\n\n// https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177\nexport function getType(fn) {\n  const type = fn !== null && fn !== undefined ? (fn.type ? fn.type : fn) : null\n  const match = type && type.toString().match(FN_MATCH_REGEXP)\n  return match && match[1]\n}\n\nexport function getNativeType(value) {\n  if (value === null || value === undefined) return null\n  const match = value.constructor.toString().match(FN_MATCH_REGEXP)\n  return match && match[1]\n}\n\n/**\n * No-op function\n */\nexport function noop() {}\n\n/**\n * A function that always returns true\n */\nexport const stubTrue = () => true\n\n/**\n * Checks for a own property in an object\n *\n * @param {object} obj - Object\n * @param {string} prop - Property to check\n * @returns {boolean}\n */\nexport const has = (obj, prop) => hasOwn.call(obj, prop)\n\n/**\n * Determines whether the passed value is an integer. Uses `Number.isInteger` if available\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @param {*} value - The value to be tested for being an integer.\n * @returns {boolean}\n */\nexport const isInteger =\n  Number.isInteger ||\n  function isInteger(value) {\n    return (\n      typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    )\n  }\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @param {*} value - The value to be tested for being an array.\n * @returns {boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function isArray(value) {\n    return toString.call(value) === '[object Array]'\n  }\n\n/**\n * Checks if a value is a function\n *\n * @param {any} value - Value to check\n * @returns {boolean}\n */\nexport const isFunction = (value) =>\n  toString.call(value) === '[object Function]'\n\n/**\n * Adds a `def` method to the object returning a new object with passed in argument as `default` property\n *\n * @param {object} type - Object to enhance\n * @returns {object} the passed-in prop type\n */\nexport function withDefault(type) {\n  return Object.defineProperty(type, 'def', {\n    value(def) {\n      if (def === undefined && !this.default) {\n        return this\n      }\n      if (!isFunction(def) && !validateType(this, def)) {\n        warn(`${this._vueTypes_name} - invalid default value: \"${def}\"`, def)\n        return this\n      }\n      if (isArray(def)) {\n        this.default = () => [...def]\n      } else if (isPlainObject(def)) {\n        this.default = () => Object.assign({}, def)\n      } else {\n        this.default = def\n      }\n      return this\n    },\n    enumerable: false,\n    writable: false,\n  })\n}\n\n/**\n * Adds a `isRequired` getter returning a new object with `required: true` key-value\n *\n * @param {object} type - Object to enhance\n * @returns {object} the passed-in prop type\n */\nexport function withRequired(type) {\n  return Object.defineProperty(type, 'isRequired', {\n    get() {\n      this.required = true\n      return this\n    },\n    enumerable: false,\n  })\n}\n\n/**\n * Adds a validate method useful to set the prop `validator` function.\n *\n * @param {object} type Prop type to extend\n * @returns {object} the passed-in prop type\n */\nexport function withValidate(type) {\n  return Object.defineProperty(type, 'validate', {\n    value(fn) {\n      this.validator = fn.bind(this)\n      return this\n    },\n    enumerable: false,\n  })\n}\n\n/**\n * Adds `isRequired` and `def` modifiers to an object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n * @param {boolean} [validateFn=false] - add the `validate()` method to the type object\n * @returns {object}\n */\nexport function toType(name, obj, validateFn = false) {\n  Object.defineProperty(obj, '_vueTypes_name', {\n    enumerable: false,\n    writable: false,\n    value: name,\n  })\n\n  withDefault(withRequired(obj))\n\n  if (validateFn) {\n    withValidate(obj)\n  } else {\n    Object.defineProperty(obj, 'validate', {\n      value() {\n        warn(`${name} - \"validate\" method not supported on this type`)\n        return this\n      },\n      enumerable: false,\n    })\n  }\n\n  if (isFunction(obj.validator)) {\n    obj.validator = obj.validator.bind(obj)\n  }\n  return obj\n}\n\n/**\n * Validates a given value against a prop type object\n *\n * @param {Object|*} type - Type to use for validation. Either a type object or a constructor\n * @param {*} value - Value to check\n * @param {boolean} silent - Silence warnings\n * @returns {boolean}\n */\nexport function validateType(type, value, silent = false) {\n  let typeToCheck = type\n  let valid = true\n  let expectedType\n  if (!isPlainObject(type)) {\n    typeToCheck = { type }\n  }\n  const namePrefix = typeToCheck._vueTypes_name\n    ? typeToCheck._vueTypes_name + ' - '\n    : ''\n\n  if (hasOwn.call(typeToCheck, 'type') && typeToCheck.type !== null) {\n    if (typeToCheck.type === undefined) {\n      throw new TypeError(\n        `[VueTypes error]: Setting type to undefined is not allowed.`,\n      )\n    }\n    if (!typeToCheck.required && value === undefined) {\n      return valid\n    }\n    if (isArray(typeToCheck.type)) {\n      valid = typeToCheck.type.some((type) => validateType(type, value, true))\n      expectedType = typeToCheck.type.map((type) => getType(type)).join(' or ')\n    } else {\n      expectedType = getType(typeToCheck)\n\n      if (expectedType === 'Array') {\n        valid = isArray(value)\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value)\n      } else if (\n        expectedType === 'String' ||\n        expectedType === 'Number' ||\n        expectedType === 'Boolean' ||\n        expectedType === 'Function'\n      ) {\n        valid = getNativeType(value) === expectedType\n      } else {\n        valid = value instanceof typeToCheck.type\n      }\n    }\n  }\n\n  if (!valid) {\n    silent === false &&\n      warn(`${namePrefix}value \"${value}\" should be of type \"${expectedType}\"`)\n    return false\n  }\n\n  if (\n    hasOwn.call(typeToCheck, 'validator') &&\n    isFunction(typeToCheck.validator)\n  ) {\n    // swallow warn\n    let oldWarn\n    if (silent) {\n      oldWarn = warn\n      warn = noop\n    }\n\n    valid = typeToCheck.validator(value)\n    oldWarn && (warn = oldWarn)\n\n    if (!valid && silent === false)\n      warn(`${namePrefix}custom validation failed`)\n    return valid\n  }\n  return valid\n}\n\nlet warn = noop\n\nif (process.env.NODE_ENV !== 'production') {\n  const hasConsole = typeof console !== 'undefined'\n  warn = hasConsole\n    ? function warn(msg) {\n        // eslint-disable-next-line no-console\n        Vue.config.silent === false && console.warn(`[VueTypes warn]: ${msg}`)\n      }\n    : noop\n}\n\nexport { warn }\n","const typeDefaults = () => ({\n  func: () => {},\n  bool: true,\n  string: '',\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0,\n})\n\nexport const setDefaults = (root) => {\n  let currentDefaults = typeDefaults()\n\n  return Object.defineProperty(root, 'sensibleDefaults', {\n    enumerable: false,\n    set(value) {\n      if (value === false) {\n        currentDefaults = {}\n      } else if (value === true) {\n        currentDefaults = typeDefaults()\n      } else {\n        currentDefaults = value\n      }\n    },\n    get() {\n      return currentDefaults\n    },\n  })\n}\n","import isPlainObject from 'is-plain-object'\nimport {\n  toType,\n  getType,\n  isFunction,\n  validateType,\n  isInteger,\n  isArray,\n  warn,\n  has,\n  stubTrue,\n} from './utils'\nimport { setDefaults } from './sensibles'\n\nconst VueTypes = {\n  get any() {\n    return toType(\n      'any',\n      {\n        type: null,\n      },\n      true,\n    )\n  },\n\n  get func() {\n    return toType(\n      'function',\n      {\n        type: Function,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.func)\n  },\n\n  get bool() {\n    return toType(\n      'boolean',\n      {\n        type: Boolean,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.bool)\n  },\n\n  get string() {\n    return toType(\n      'string',\n      {\n        type: String,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.string)\n  },\n\n  get number() {\n    return toType(\n      'number',\n      {\n        type: Number,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.number)\n  },\n\n  get array() {\n    return toType(\n      'array',\n      {\n        type: Array,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.array)\n  },\n\n  get object() {\n    return toType(\n      'object',\n      {\n        type: Object,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.object)\n  },\n\n  get integer() {\n    return toType('integer', {\n      type: Number,\n      validator(value) {\n        return isInteger(value)\n      },\n    }).def(VueTypes.sensibleDefaults.integer)\n  },\n\n  get symbol() {\n    return toType(\n      'symbol',\n      {\n        type: null,\n        validator(value) {\n          return typeof value === 'symbol'\n        },\n      },\n      true,\n    )\n  },\n\n  extend(props = {}) {\n    if (isArray(props)) {\n      props.forEach((p) => VueTypes.extend(p))\n      return this\n    }\n\n    let { name, validate = false, getter = false, ...opts } = props\n\n    if (has(VueTypes, name)) {\n      throw new TypeError(`[VueTypes error]: Type \"${name}\" already defined`)\n    }\n\n    const { type, validator = stubTrue } = opts\n    if (type && type._vueTypes_name) {\n      // we are using as base type a vue-type object\n\n      // detach the original type\n      // we are going to inherit the parent data.\n      delete opts.type\n\n      // inherit base types, required flag and default flag if set\n      const keys = ['type', 'required', 'default']\n      for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i]\n        if (type[key] !== undefined) {\n          opts[key] = type[key]\n        }\n      }\n\n      validate = false // we don't allow validate method on this kind of types\n      if (isFunction(type.validator)) {\n        opts.validator = function (...args) {\n          return type.validator.apply(type, args) && validator.apply(this, args)\n        }\n      }\n    }\n    let descriptor\n    if (getter) {\n      descriptor = {\n        get() {\n          return toType(name, Object.assign({}, opts), validate)\n        },\n        enumerable: true,\n        configurable: false,\n      }\n    } else {\n      const { validator } = opts\n      descriptor = {\n        value(...args) {\n          const ret = toType(name, Object.assign({}, opts), validate)\n          if (validator) {\n            ret.validator = validator.bind(ret, ...args)\n          }\n          return ret\n        },\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      }\n    }\n\n    return Object.defineProperty(this, name, descriptor)\n  },\n\n  custom(validatorFn, warnMsg = 'custom validation failed') {\n    if (typeof validatorFn !== 'function') {\n      throw new TypeError(\n        '[VueTypes error]: You must provide a function as argument',\n      )\n    }\n\n    return toType(validatorFn.name || '<<anonymous function>>', {\n      validator(value) {\n        const valid = validatorFn(value)\n        if (!valid) warn(`${this._vueTypes_name} - ${warnMsg}`)\n        return valid\n      },\n    })\n  },\n\n  oneOf(arr) {\n    if (!isArray(arr)) {\n      throw new TypeError(\n        '[VueTypes error]: You must provide an array as argument',\n      )\n    }\n    const msg = `oneOf - value should be one of \"${arr.join('\", \"')}\"`\n    const allowedTypes = arr.reduce((ret, v) => {\n      if (v !== null && v !== undefined) {\n        ret.indexOf(v.constructor) === -1 && ret.push(v.constructor)\n      }\n      return ret\n    }, [])\n\n    return toType('oneOf', {\n      type: allowedTypes.length > 0 ? allowedTypes : null,\n      validator(value) {\n        const valid = arr.indexOf(value) !== -1\n        if (!valid) warn(msg)\n        return valid\n      },\n    })\n  },\n\n  instanceOf(instanceConstructor) {\n    return toType('instanceOf', {\n      type: instanceConstructor,\n    })\n  },\n\n  oneOfType(arr) {\n    if (!isArray(arr)) {\n      throw new TypeError(\n        '[VueTypes error]: You must provide an array as argument',\n      )\n    }\n\n    let hasCustomValidators = false\n\n    const nativeChecks = arr.reduce((ret, type) => {\n      if (isPlainObject(type)) {\n        if (type._vueTypes_name === 'oneOf') {\n          return ret.concat(type.type || [])\n        }\n        if (isFunction(type.validator)) {\n          hasCustomValidators = true\n          return ret\n        }\n        if (type.type) {\n          if (isArray(type.type)) return ret.concat(type.type)\n          ret.push(type.type)\n        }\n\n        return ret\n      }\n      ret.push(type)\n      return ret\n    }, [])\n\n    if (!hasCustomValidators) {\n      // we got just native objects (ie: Array, Object)\n      // delegate to Vue native prop check\n      return toType('oneOfType', {\n        type: nativeChecks,\n      })\n    }\n\n    const typesStr = arr\n      .map((type) => {\n        if (type && isArray(type.type)) {\n          return type.type.map(getType)\n        }\n        return getType(type)\n      })\n      .reduce((ret, type) => ret.concat(isArray(type) ? type : [type]), [])\n      .join('\", \"')\n\n    return this.custom(function oneOfType(value) {\n      const valid = arr.some((type) => {\n        if (type._vueTypes_name === 'oneOf') {\n          return type.type ? validateType(type.type, value, true) : true\n        }\n        return validateType(type, value, true)\n      })\n      if (!valid) warn(`oneOfType - value type should be one of \"${typesStr}\"`)\n      return valid\n    })\n  },\n\n  arrayOf(type) {\n    return toType('arrayOf', {\n      type: Array,\n      validator(values) {\n        const valid = values.every((value) => validateType(type, value))\n        if (!valid)\n          warn(`arrayOf - value must be an array of \"${getType(type)}\"`)\n        return valid\n      },\n    })\n  },\n\n  objectOf(type) {\n    return toType('objectOf', {\n      type: Object,\n      validator(obj) {\n        const valid = Object.keys(obj).every((key) =>\n          validateType(type, obj[key]),\n        )\n        if (!valid)\n          warn(`objectOf - value must be an object of \"${getType(type)}\"`)\n        return valid\n      },\n    })\n  },\n\n  shape(obj) {\n    const keys = Object.keys(obj)\n    const requiredKeys = keys.filter(\n      (key) => obj[key] && obj[key].required === true,\n    )\n\n    const type = toType('shape', {\n      type: Object,\n      validator(value) {\n        if (!isPlainObject(value)) {\n          return false\n        }\n        const valueKeys = Object.keys(value)\n\n        // check for required keys (if any)\n        if (\n          requiredKeys.length > 0 &&\n          requiredKeys.some((req) => valueKeys.indexOf(req) === -1)\n        ) {\n          warn(\n            `shape - at least one of required properties \"${requiredKeys.join(\n              '\", \"',\n            )}\" is not present`,\n          )\n          return false\n        }\n\n        return valueKeys.every((key) => {\n          if (keys.indexOf(key) === -1) {\n            if (this._vueTypes_isLoose === true) return true\n            warn(`shape - object is missing \"${key}\" property`)\n            return false\n          }\n          const type = obj[key]\n          return validateType(type, value[key])\n        })\n      },\n    })\n\n    Object.defineProperty(type, '_vueTypes_isLoose', {\n      enumerable: false,\n      writable: true,\n      value: false,\n    })\n\n    Object.defineProperty(type, 'loose', {\n      get() {\n        this._vueTypes_isLoose = true\n        return this\n      },\n      enumerable: false,\n    })\n\n    return type\n  },\n}\n\nsetDefaults(VueTypes)\n\nVueTypes.utils = {\n  validate(value, type) {\n    return validateType(type, value, true)\n  },\n  toType,\n}\n\nexport default VueTypes\n"],"names":["isObjectObject","o","val","Array","isArray","Object","prototype","toString","call","isPlainObject","ctor","prot","constructor","hasOwnProperty","ObjProto","hasOwn","FN_MATCH_REGEXP","getType","fn","type","match","noop","stubTrue","isInteger","Number","value","isFinite","Math","floor","isFunction","toType","name","obj","validateFn","defineProperty","enumerable","writable","get","required","this","def","undefined","default","validateType","assign","warn","_vueTypes_name","validator","bind","silent","expectedType","typeToCheck","valid","oldWarn","namePrefix","TypeError","some","map","join","getNativeType","typeDefaults","func","bool","string","number","array","object","integer","root","currentDefaults","VueTypes","Function","sensibleDefaults","Boolean","String","extend","props","forEach","p","prop","validate","getter","opts","descriptor","keys","i","length","key","args","apply","configurable","ret","custom","validatorFn","warnMsg","oneOf","arr","msg","allowedTypes","reduce","v","indexOf","push","instanceOf","instanceConstructor","oneOfType","hasCustomValidators","nativeChecks","concat","typesStr","arrayOf","values","every","objectOf","shape","requiredKeys","filter","valueKeys","req","_this","_vueTypes_isLoose","set","utils"],"mappings":";;;;;;;;;;;;AASA,SAASA,EAAeC,GACtB,OAAuB,ICFT,OADiBC,EDGfD,ICFqB,iBAARC,IAA2C,IAAvBC,MAAMC,QAAQF,KDGpB,oBAAtCG,OAAOC,UAAUC,SAASC,KAAKP;;;;;;;ACJvB,IAAkBC,EDOlB,SAASO,EAAcR,GACpC,IAAIS,EAAKC,EAET,OAA0B,IAAtBX,EAAeC,KAIC,mBADpBS,EAAOT,EAAEW,gBAKoB,IAAzBZ,EADJW,EAAOD,EAAKJ,aAIiC,IAAzCK,EAAKE,eAAe,sFEzB1B,IAAMC,EAAWT,OAAOC,UAClBC,EAAWO,EAASP,SACbQ,EAASD,EAASD,eAEzBG,EAAkB,qBAGjB,SAASC,EAAQC,OAChBC,EAAOD,MAAAA,EAAmCA,EAAGC,KAAOD,EAAGC,KAAOD,EAAM,KACpEE,EAAQD,GAAQA,EAAKZ,WAAWa,MAAMJ,UACrCI,GAASA,EAAM,GAYjB,SAASC,KAKQ,SAAXC,WAAiB,EAAvB,IAkBMC,EACXC,OAAOD,WACP,SAAmBE,SAEE,iBAAVA,GACPC,SAASD,IACTE,KAAKC,MAAMH,KAAWA,GAUfrB,EACXD,MAAMC,SACN,SAAiBqB,SACiB,mBAAzBlB,EAASC,KAAKiB,IASZI,EAAa,SAACJ,SACA,sBAAzBlB,EAASC,KAAKiB,IAwET,SAASK,EAAOC,EAAMC,EAAKC,GAhE3B,IAAqBd,EA8BCA,EAgBAA,kBAkBKc,IAAAA,GAAa,GAC7C5B,OAAO6B,eAAeF,EAAK,iBAAkB,CAC3CG,YAAY,EACZC,UAAU,EACVX,MAAOM,IAtCkBZ,EAyCFa,EAvECb,EA+BnBd,OAAO6B,eAAef,EAAM,aAAc,CAC/CkB,2BACOC,UAAW,EACTC,MAETJ,YAAY,IAnCP9B,OAAO6B,eAAef,EAAM,MAAO,CACxCM,eAAMe,eACQC,IAARD,IAAsBD,KAAKG,UAG1Bb,EAAWW,IAASG,EAAaJ,KAAMC,GAIxCpC,EAAQoC,QACLE,QAAU,2BAAUF,IAChB/B,EAAc+B,QAClBE,QAAU,kBAAMrC,OAAOuC,OAAO,GAAIJ,SAElCE,QAAUF,EARfK,EAAQN,KAAKO,6CAA4CN,MAAQA,IAU5DD,MAETJ,YAAY,EACZC,UAAU,IAqDRH,GA3BuBd,EA4BZa,EA3BR3B,OAAO6B,eAAef,EAAM,WAAY,CAC7CM,eAAMP,eACC6B,UAAY7B,EAAG8B,KAAKT,MAClBA,MAETJ,YAAY,KAwBZ9B,OAAO6B,eAAeF,EAAK,WAAY,CACrCP,wBACEoB,EAAQd,qDACDQ,MAETJ,YAAY,IAIZN,EAAWG,EAAIe,aACjBf,EAAIe,UAAYf,EAAIe,UAAUC,KAAKhB,IAE9BA,EAWF,SAASW,EAAaxB,EAAMM,EAAOwB,YAAAA,IAAAA,GAAS,OAG7CC,EAFAC,EAAchC,EACdiC,GAAQ,EAEP3C,EAAcU,KACjBgC,EAAc,CAAEhC,KAAAA,QAiDZkC,EA/CAC,EAAaH,EAAYL,eAC3BK,EAAYL,eAAiB,MAC7B,MAEA/B,EAAOP,KAAK2C,EAAa,SAAgC,OAArBA,EAAYhC,KAAe,SACxCsB,IAArBU,EAAYhC,WACR,IAAIoC,6EAIPJ,EAAYb,eAAsBG,IAAVhB,SACpB2B,EAELhD,EAAQ+C,EAAYhC,OACtBiC,EAAQD,EAAYhC,KAAKqC,KAAK,SAACrC,UAASwB,EAAaxB,EAAMM,GAAO,KAClEyB,EAAeC,EAAYhC,KAAKsC,IAAI,SAACtC,UAASF,EAAQE,KAAOuC,KAAK,SAKhEN,EADmB,WAFrBF,EAAejC,EAAQkC,IAGb/C,EAAQqB,GACU,WAAjByB,EACDzC,EAAcgB,GAEL,WAAjByB,GACiB,WAAjBA,GACiB,YAAjBA,GACiB,aAAjBA,EA1MD,SAAuBzB,MACxBA,MAAAA,EAAuC,OAAO,SAC5CL,EAAQK,EAAMb,YAAYL,WAAWa,MAAMJ,UAC1CI,GAASA,EAAM,GAyMRuC,CAAclC,KAAWyB,EAEzBzB,aAAiB0B,EAAYhC,YAKtCiC,GAOHrC,EAAOP,KAAK2C,EAAa,cACzBtB,EAAWsB,EAAYJ,aAInBE,IACFI,EAAUR,EACVA,EAAOxB,GAGT+B,EAAQD,EAAYJ,UAAUtB,GAC9B4B,IAAYR,EAAOQ,GAEdD,IAAoB,IAAXH,GACZJ,EAAQS,+BACHF,KArBI,IAAXH,GACEJ,EAAQS,YAAoB7B,0BAA6ByB,QACpD,GCtOU,SAAfU,UAAsB,CAC1BC,KAAM,aACNC,MAAM,EACNC,OAAQ,GACRC,OAAQ,EACRC,MAAO,iBAAM,IACbC,OAAQ,iBAAO,IACfC,QAAS,GDuPX,ICpP4BC,EACtBC,EDmPFxB,EAAOxB,EEhPLiD,EAAW,kBAENxC,EACL,MACA,CACEX,KAAM,OAER,sBAKKW,EACL,WACA,CACEX,KAAMoD,WAER,GACA/B,IAAI8B,EAASE,iBAAiBX,yBAIzB/B,EACL,UACA,CACEX,KAAMsD,UAER,GACAjC,IAAI8B,EAASE,iBAAiBV,2BAIzBhC,EACL,SACA,CACEX,KAAMuD,SAER,GACAlC,IAAI8B,EAASE,iBAAiBT,6BAIzBjC,EACL,SACA,CACEX,KAAMK,SAER,GACAgB,IAAI8B,EAASE,iBAAiBR,4BAIzBlC,EACL,QACA,CACEX,KAAMhB,QAER,GACAqC,IAAI8B,EAASE,iBAAiBP,4BAIzBnC,EACL,SACA,CACEX,KAAMd,SAER,GACAmC,IAAI8B,EAASE,iBAAiBN,8BAIzBpC,EAAO,UAAW,CACvBX,KAAMK,OACNuB,mBAAUtB,UACDF,EAAUE,MAElBe,IAAI8B,EAASE,iBAAiBL,8BAI1BrC,EACL,SACA,CACEX,KAAM,KACN4B,mBAAUtB,SACgB,iBAAVA,KAGlB,IAIJkD,gBAAOC,eAAAA,IAAAA,EAAQ,IACTxE,EAAQwE,UACVA,EAAMC,QAAQ,SAACC,UAAMR,EAASK,OAAOG,KAC9BvC,SFvEOP,EAAK+C,EE0EfhD,EAAoD6C,EAApD7C,OAAoD6C,EAA9CI,SAAAA,kBAA8CJ,EAA5BK,OAAAA,gBAAmBC,uIAASN,mCF1E1C5C,EE4ERsC,EF5EaS,EE4EHhD,EF5EYhB,EAAOP,KAAKwB,EAAK+C,SE6EvC,IAAIxB,qCAAqCxB,2BA2B7CoD,EAxBIhE,EAA+B+D,EAA/B/D,OAA+B+D,EAAzBnC,UAAAA,aAAYzB,OACtBH,GAAQA,EAAK2B,eAAgB,QAKxBoC,EAAK/D,aAGNiE,EAAO,CAAC,OAAQ,WAAY,WACzBC,EAAI,EAAGA,EAAID,EAAKE,OAAQD,GAAK,EAAG,KACjCE,EAAMH,EAAKC,QACC5C,IAAdtB,EAAKoE,KACPL,EAAKK,GAAOpE,EAAKoE,IAIrBP,GAAW,EACPnD,EAAWV,EAAK4B,aAClBmC,EAAKnC,UAAY,sCAAayC,2BAAAA,yBACrBrE,EAAK4B,UAAU0C,MAAMtE,EAAMqE,IAASzC,EAAU0C,MAAMlD,KAAMiD,QAKnEP,EACFE,EAAa,CACX9C,sBACSP,EAAOC,EAAM1B,OAAOuC,OAAO,GAAIsC,GAAOF,IAE/C7C,YAAY,EACZuD,cAAc,OAEX,KACG3C,EAAcmC,EAAdnC,UACRoC,EAAa,CACX1D,qBACQkE,EAAM7D,EAAOC,EAAM1B,OAAOuC,OAAO,GAAIsC,GAAOF,MAC9CjC,EAAW,4BAFRyC,2BAAAA,kBAGLG,EAAI5C,UAAYA,EAAUC,WAAVD,GAAe4C,UAAQH,WAElCG,GAETvD,UAAU,EACVD,YAAY,EACZuD,cAAc,UAIXrF,OAAO6B,eAAeK,KAAMR,EAAMoD,IAG3CS,gBAAOC,EAAaC,eAAAA,IAAAA,EAAU,4BACD,mBAAhBD,QACH,IAAItC,UACR,oEAIGzB,EAAO+D,EAAY9D,MAAQ,yBAA0B,CAC1DgB,mBAAUtB,OACF2B,EAAQyC,EAAYpE,UACrB2B,GAAOP,EAAQN,KAAKO,qBAAoBgD,GACtC1C,MAKb2C,eAAMC,OACC5F,EAAQ4F,SACL,IAAIzC,UACR,+DAGE0C,qCAAyCD,EAAItC,KAAK,YAClDwC,EAAeF,EAAIG,OAAO,SAACR,EAAKS,UAChCA,MAAAA,IAC8B,IAAhCT,EAAIU,QAAQD,EAAExF,cAAuB+E,EAAIW,KAAKF,EAAExF,aAE3C+E,GACN,WAEI7D,EAAO,QAAS,CACrBX,KAA4B,EAAtB+E,EAAaZ,OAAaY,EAAe,KAC/CnD,mBAAUtB,OACF2B,GAAgC,IAAxB4C,EAAIK,QAAQ5E,UACrB2B,GAAOP,EAAKoD,GACV7C,MAKbmD,oBAAWC,UACF1E,EAAO,aAAc,CAC1BX,KAAMqF,KAIVC,mBAAUT,OACH5F,EAAQ4F,SACL,IAAIzC,UACR,+DAIAmD,GAAsB,EAEpBC,EAAeX,EAAIG,OAAO,SAACR,EAAKxE,MAChCV,EAAcU,GAAO,IACK,UAAxBA,EAAK2B,sBACA6C,EAAIiB,OAAOzF,EAAKA,MAAQ,OAE7BU,EAAWV,EAAK4B,kBAClB2D,GAAsB,EACff,KAELxE,EAAKA,KAAM,IACTf,EAAQe,EAAKA,MAAO,OAAOwE,EAAIiB,OAAOzF,EAAKA,MAC/CwE,EAAIW,KAAKnF,EAAKA,aAGTwE,SAETA,EAAIW,KAAKnF,GACFwE,GACN,QAEEe,SAGI5E,EAAO,YAAa,CACzBX,KAAMwF,QAIJE,EAAWb,EACdvC,IAAI,SAACtC,UACAA,GAAQf,EAAQe,EAAKA,MAChBA,EAAKA,KAAKsC,IAAIxC,GAEhBA,EAAQE,KAEhBgF,OAAO,SAACR,EAAKxE,UAASwE,EAAIiB,OAAOxG,EAAQe,GAAQA,EAAO,CAACA,KAAQ,IACjEuC,KAAK,eAEDnB,KAAKqD,OAAO,SAAmBnE,OAC9B2B,EAAQ4C,EAAIxC,KAAK,SAACrC,SACM,UAAxBA,EAAK2B,gBACA3B,EAAKA,MAAOwB,EAAaxB,EAAKA,KAAMM,GAAO,GAE7CkB,EAAaxB,EAAMM,GAAO,YAE9B2B,GAAOP,8CAAiDgE,OACtDzD,KAIX0D,iBAAQ3F,UACCW,EAAO,UAAW,CACvBX,KAAMhB,MACN4C,mBAAUgE,OACF3D,EAAQ2D,EAAOC,MAAM,SAACvF,UAAUkB,EAAaxB,EAAMM,YACpD2B,GACHP,0CAA6C5B,EAAQE,QAChDiC,MAKb6D,kBAAS9F,UACAW,EAAO,WAAY,CACxBX,KAAMd,OACN0C,mBAAUf,OACFoB,EAAQ/C,OAAO+E,KAAKpD,GAAKgF,MAAM,SAACzB,UACpC5C,EAAaxB,EAAMa,EAAIuD,aAEpBnC,GACHP,4CAA+C5B,EAAQE,QAClDiC,MAKb8D,eAAMlF,OACEoD,EAAO/E,OAAO+E,KAAKpD,GACnBmF,EAAe/B,EAAKgC,OACxB,SAAC7B,UAAQvD,EAAIuD,KAA8B,IAAtBvD,EAAIuD,GAAKjD,WAG1BnB,EAAOW,EAAO,QAAS,CAC3BX,KAAMd,OACN0C,mBAAUtB,kBACHhB,EAAcgB,UACV,MAEH4F,EAAYhH,OAAO+E,KAAK3D,UAIN,EAAtB0F,EAAa7B,QACb6B,EAAa3D,KAAK,SAAC8D,UAAoC,IAA5BD,EAAUhB,QAAQiB,MAE7CzE,kDACkDsE,EAAazD,KAC3D,6BAGG,GAGF2D,EAAUL,MAAM,SAACzB,UACK,IAAvBH,EAAKiB,QAAQd,IACgB,IAA3BgC,EAAKC,oBACT3E,gCAAmC0C,iBAC5B,GAGF5C,EADMX,EAAIuD,GACS9D,EAAM8D,gBAKtClF,OAAO6B,eAAef,EAAM,oBAAqB,CAC/CgB,YAAY,EACZC,UAAU,EACVX,OAAO,IAGTpB,OAAO6B,eAAef,EAAM,QAAS,CACnCkB,2BACOmF,mBAAoB,EAClBjF,MAETJ,YAAY,IAGPhB,WDzViBiD,EC6VhBE,ED5VND,EAAkBT,IAEfvD,OAAO6B,eAAekC,EAAM,mBAAoB,CACrDjC,YAAY,EACZsF,aAAIhG,GAEA4C,GADY,IAAV5C,EACgB,IACC,IAAVA,EACSmC,IAEAnC,GAGtBY,sBACSgC,KCgVbC,EAASoD,MAAQ,CACf1C,kBAASvD,EAAON,UACPwB,EAAaxB,EAAMM,GAAO,IAEnCK,OAAAA"}