{"version":3,"file":"vue-types.min.js","sources":["../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/_overArg.js","../node_modules/lodash/_getPrototype.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isPlainObject.js","../src/utils.js","../src/sensibles.js","../src/index.js"],"sourcesContent":["/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","import isPlainObject from 'lodash/isPlainObject'\nimport Vue from 'vue'\n\nconst ObjProto = Object.prototype\nconst toString = ObjProto.toString\nexport const hasOwn = ObjProto.hasOwnProperty\n\nconst FN_MATCH_REGEXP = /^\\s*function (\\w+)/\n\n// https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177\nexport const getType = (fn) => {\n  const type = fn !== null && fn !== undefined ? (fn.type ? fn.type : fn) : null\n  const match = type && type.toString().match(FN_MATCH_REGEXP)\n  return match && match[1]\n}\n\nexport const getNativeType = (value) => {\n  if (value === null || value === undefined) return null\n  const match = value.constructor.toString().match(FN_MATCH_REGEXP)\n  return match && match[1]\n}\n\n/**\n * No-op function\n */\nexport const noop = () => {}\n\n/**\n * Checks for a own property in an object\n *\n * @param {object} obj - Object\n * @param {string} prop - Property to check\n */\nexport const has = (obj, prop) => hasOwn.call(obj, prop)\n\n/**\n * Determines whether the passed value is an integer. Uses `Number.isInteger` if available\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @param {*} value - The value to be tested for being an integer.\n * @returns {boolean}\n */\nexport const isInteger =\n  Number.isInteger ||\n  function(value) {\n    return (\n      typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    )\n  }\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @param {*} value - The value to be tested for being an array.\n * @returns {boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function(value) {\n    return toString.call(value) === '[object Array]'\n  }\n\n/**\n * Checks if a value is a function\n *\n * @param {any} value - Value to check\n * @returns {boolean}\n */\nexport const isFunction = (value) =>\n  toString.call(value) === '[object Function]'\n\n/**\n * Adds a `def` method to the object returning a new object with passed in argument as `default` property\n *\n * @param {object} type - Object to enhance\n * @returns {object} the passed-in prop type\n */\nexport const withDefault = function(type) {\n  return Object.defineProperty(type, 'def', {\n    value(def) {\n      if (def === undefined && !this.default) {\n        return this\n      }\n      if (!isFunction(def) && !validateType(this, def)) {\n        warn(`${this._vueTypes_name} - invalid default value: \"${def}\"`, def)\n        return this\n      }\n      if (isArray(def)) {\n        this.default = () => [...def]\n      } else if (isPlainObject(def)) {\n        this.default = () => Object.assign({}, def)\n      } else {\n        this.default = def\n      }\n      return this\n    },\n    enumerable: false,\n    writable: false,\n  })\n}\n\n/**\n * Adds a `isRequired` getter returning a new object with `required: true` key-value\n *\n * @param {object} type - Object to enhance\n * @returns {object} the passed-in prop type\n */\nexport const withRequired = function(type) {\n  return Object.defineProperty(type, 'isRequired', {\n    get() {\n      this.required = true\n      return this\n    },\n    enumerable: false,\n  })\n}\n\n/**\n * Adds a validate method useful to set the prop `validator` function.\n *\n * @param {object} type Prop type to extend\n * @returns {object} the passed-in prop type\n */\nexport const withValidate = function(type) {\n  return Object.defineProperty(type, 'validate', {\n    value(fn) {\n      this.validator = fn.bind(this)\n      return this\n    },\n    enumerable: false,\n  })\n}\n\n/**\n * Adds `isRequired` and `def` modifiers to an object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n * @returns {object}\n */\nexport const toType = (name, obj, validateFn = false) => {\n  Object.defineProperty(obj, '_vueTypes_name', {\n    enumerable: false,\n    writable: false,\n    value: name,\n  })\n\n  withDefault(withRequired(obj))\n\n  if (validateFn) {\n    withValidate(obj)\n  }\n\n  if (isFunction(obj.validator)) {\n    obj.validator = obj.validator.bind(obj)\n  }\n  return obj\n}\n\n/**\n * Validates a given value against a prop type object\n *\n * @param {Object|*} type - Type to use for validation. Either a type object or a constructor\n * @param {*} value - Value to check\n * @param {boolean} silent - Silence warnings\n * @returns {boolean}\n */\nexport const validateType = (type, value, silent = false) => {\n  let typeToCheck = type\n  let valid = true\n  let expectedType\n  if (!isPlainObject(type)) {\n    typeToCheck = { type }\n  }\n  const namePrefix = typeToCheck._vueTypes_name\n    ? typeToCheck._vueTypes_name + ' - '\n    : ''\n\n  if (hasOwn.call(typeToCheck, 'type') && typeToCheck.type !== null) {\n    if (isArray(typeToCheck.type)) {\n      valid = typeToCheck.type.some((type) => validateType(type, value, true))\n      expectedType = typeToCheck.type.map((type) => getType(type)).join(' or ')\n    } else {\n      expectedType = getType(typeToCheck)\n\n      if (expectedType === 'Array') {\n        valid = isArray(value)\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value)\n      } else if (\n        expectedType === 'String' ||\n        expectedType === 'Number' ||\n        expectedType === 'Boolean' ||\n        expectedType === 'Function'\n      ) {\n        valid = getNativeType(value) === expectedType\n      } else {\n        valid = value instanceof typeToCheck.type\n      }\n    }\n  }\n\n  if (!valid) {\n    silent === false &&\n      warn(`${namePrefix}value \"${value}\" should be of type \"${expectedType}\"`)\n    return false\n  }\n\n  if (\n    hasOwn.call(typeToCheck, 'validator') &&\n    isFunction(typeToCheck.validator)\n  ) {\n    // swallow warn\n    let oldWarn\n    if (silent) {\n      oldWarn = warn\n      warn = noop\n    }\n\n    valid = typeToCheck.validator(value)\n    oldWarn && (warn = oldWarn)\n\n    if (!valid && silent === false)\n      warn(`${namePrefix}custom validation failed`)\n    return valid\n  }\n  return valid\n}\n\nlet warn = noop\n\nif (process.env.NODE_ENV !== 'production') {\n  const hasConsole = typeof console !== 'undefined'\n  warn = hasConsole\n    ? (msg) => {\n        // eslint-disable-next-line no-console\n        Vue.config.silent === false && console.warn(`[VueTypes warn]: ${msg}`)\n      }\n    : noop\n}\n\nexport { warn }\n","const typeDefaults = () => ({\n  func: () => {},\n  bool: true,\n  string: '',\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0,\n})\n\nexport const setDefaults = (root) => {\n  let currentDefaults = typeDefaults()\n\n  return Object.defineProperty(root, 'sensibleDefaults', {\n    enumerable: false,\n    set(value) {\n      if (value === false) {\n        currentDefaults = {}\n      } else if (value === true) {\n        currentDefaults = typeDefaults()\n      } else {\n        currentDefaults = value\n      }\n    },\n    get() {\n      return currentDefaults\n    },\n  })\n}\n","import isPlainObject from 'lodash/isPlainObject'\nimport {\n  toType,\n  getType,\n  isFunction,\n  validateType,\n  isInteger,\n  isArray,\n  warn,\n} from './utils'\nimport { setDefaults } from './sensibles'\n\nconst VueTypes = {\n  get any() {\n    return toType(\n      'any',\n      {\n        type: null,\n      },\n      true,\n    )\n  },\n\n  get func() {\n    return toType(\n      'function',\n      {\n        type: Function,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.func)\n  },\n\n  get bool() {\n    return toType(\n      'boolean',\n      {\n        type: Boolean,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.bool)\n  },\n\n  get string() {\n    return toType(\n      'string',\n      {\n        type: String,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.string)\n  },\n\n  get number() {\n    return toType(\n      'number',\n      {\n        type: Number,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.number)\n  },\n\n  get array() {\n    return toType(\n      'array',\n      {\n        type: Array,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.array)\n  },\n\n  get object() {\n    return toType(\n      'object',\n      {\n        type: Object,\n      },\n      true,\n    ).def(VueTypes.sensibleDefaults.object)\n  },\n\n  get integer() {\n    return toType('integer', {\n      type: Number,\n      validator(value) {\n        return isInteger(value)\n      },\n    }).def(VueTypes.sensibleDefaults.integer)\n  },\n\n  get symbol() {\n    return toType(\n      'symbol',\n      {\n        type: null,\n        validator(value) {\n          return typeof value === 'symbol'\n        },\n      },\n      true,\n    )\n  },\n\n  extend(props = {}) {\n    const { name, validate = false, getter = false, ...type } = props\n    let descriptor\n    if (getter) {\n      descriptor = {\n        get() {\n          return toType(name, Object.assign({}, type), validate)\n        },\n        enumerable: true,\n        configurable: false,\n      }\n    } else {\n      const { validator } = type\n      descriptor = {\n        value(...args) {\n          const ret = toType(name, Object.assign({}, type), validate)\n          if (validator) {\n            ret.validator = validator.bind(ret, ...args)\n          }\n          return ret\n        },\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      }\n    }\n\n    return Object.defineProperty(this, name, descriptor)\n  },\n\n  custom(validatorFn, warnMsg = 'custom validation failed') {\n    if (typeof validatorFn !== 'function') {\n      throw new TypeError(\n        '[VueTypes error]: You must provide a function as argument',\n      )\n    }\n\n    return toType(validatorFn.name || '<<anonymous function>>', {\n      validator(value) {\n        const valid = validatorFn(value)\n        if (!valid) warn(`${this._vueTypes_name} - ${warnMsg}`)\n        return valid\n      },\n    })\n  },\n\n  oneOf(arr) {\n    if (!isArray(arr)) {\n      throw new TypeError(\n        '[VueTypes error]: You must provide an array as argument',\n      )\n    }\n    const msg = `oneOf - value should be one of \"${arr.join('\", \"')}\"`\n    const allowedTypes = arr.reduce((ret, v) => {\n      if (v !== null && v !== undefined) {\n        ret.indexOf(v.constructor) === -1 && ret.push(v.constructor)\n      }\n      return ret\n    }, [])\n\n    return toType('oneOf', {\n      type: allowedTypes.length > 0 ? allowedTypes : null,\n      validator(value) {\n        const valid = arr.indexOf(value) !== -1\n        if (!valid) warn(msg)\n        return valid\n      },\n    })\n  },\n\n  instanceOf(instanceConstructor) {\n    return toType('instanceOf', {\n      type: instanceConstructor,\n    })\n  },\n\n  oneOfType(arr) {\n    if (!isArray(arr)) {\n      throw new TypeError(\n        '[VueTypes error]: You must provide an array as argument',\n      )\n    }\n\n    let hasCustomValidators = false\n\n    const nativeChecks = arr.reduce((ret, type) => {\n      if (isPlainObject(type)) {\n        if (type._vueTypes_name === 'oneOf') {\n          return ret.concat(type.type || [])\n        }\n        if (type.type && !isFunction(type.validator)) {\n          if (isArray(type.type)) return ret.concat(type.type)\n          ret.push(type.type)\n        } else if (isFunction(type.validator)) {\n          hasCustomValidators = true\n        }\n        return ret\n      }\n      ret.push(type)\n      return ret\n    }, [])\n\n    if (!hasCustomValidators) {\n      // we got just native objects (ie: Array, Object)\n      // delegate to Vue native prop check\n      return toType('oneOfType', {\n        type: nativeChecks,\n      })\n    }\n\n    const typesStr = arr\n      .map((type) => {\n        if (type && isArray(type.type)) {\n          return type.type.map(getType)\n        }\n        return getType(type)\n      })\n      .reduce((ret, type) => ret.concat(isArray(type) ? type : [type]), [])\n      .join('\", \"')\n\n    return this.custom(function oneOfType(value) {\n      const valid = arr.some((type) => {\n        if (type._vueTypes_name === 'oneOf') {\n          return type.type ? validateType(type.type, value, true) : true\n        }\n        return validateType(type, value, true)\n      })\n      if (!valid) warn(`oneOfType - value type should be one of \"${typesStr}\"`)\n      return valid\n    })\n  },\n\n  arrayOf(type) {\n    return toType('arrayOf', {\n      type: Array,\n      validator(values) {\n        const valid = values.every((value) => validateType(type, value))\n        if (!valid)\n          warn(`arrayOf - value must be an array of \"${getType(type)}\"`)\n        return valid\n      },\n    })\n  },\n\n  objectOf(type) {\n    return toType('objectOf', {\n      type: Object,\n      validator(obj) {\n        const valid = Object.keys(obj).every((key) =>\n          validateType(type, obj[key]),\n        )\n        if (!valid)\n          warn(`objectOf - value must be an object of \"${getType(type)}\"`)\n        return valid\n      },\n    })\n  },\n\n  shape(obj) {\n    const keys = Object.keys(obj)\n    const requiredKeys = keys.filter(\n      (key) => obj[key] && obj[key].required === true,\n    )\n\n    const type = toType('shape', {\n      type: Object,\n      validator(value) {\n        if (!isPlainObject(value)) {\n          return false\n        }\n        const valueKeys = Object.keys(value)\n\n        // check for required keys (if any)\n        if (\n          requiredKeys.length > 0 &&\n          requiredKeys.some((req) => valueKeys.indexOf(req) === -1)\n        ) {\n          warn(\n            `shape - at least one of required properties \"${requiredKeys.join(\n              '\", \"',\n            )}\" is not present`,\n          )\n          return false\n        }\n\n        return valueKeys.every((key) => {\n          if (keys.indexOf(key) === -1) {\n            if (this._vueTypes_isLoose === true) return true\n            warn(`shape - object is missing \"${key}\" property`)\n            return false\n          }\n          const type = obj[key]\n          return validateType(type, value[key])\n        })\n      },\n    })\n\n    Object.defineProperty(type, '_vueTypes_isLoose', {\n      enumerable: false,\n      writable: true,\n      value: false,\n    })\n\n    Object.defineProperty(type, 'loose', {\n      get() {\n        this._vueTypes_isLoose = true\n        return this\n      },\n      enumerable: false,\n    })\n\n    return type\n  },\n}\n\nsetDefaults(VueTypes)\n\nVueTypes.utils = {\n  validate(value, type) {\n    return validateType(type, value, true)\n  },\n  toType,\n}\n\nexport default VueTypes\n"],"names":["global","Object","freeSelf","self","freeGlobal","Function","Symbol","objectProto","prototype","hasOwnProperty","nativeObjectToString","toString","symToStringTag","toStringTag","undefined","value","isOwn","call","tag","unmasked","e","result","getRawTag","objectToString","func","transform","arg","overArg","getPrototypeOf","funcProto","funcToString","objectCtorString","getType","fn","type","match","FN_MATCH_REGEXP","noop","isFunction","toType","name","obj","validateFn","defineProperty","enumerable","writable","def","this","default","validateType","isArray","isPlainObject","assign","warn","_vueTypes_name","withDefault","get","required","withRequired","validator","bind","withValidate","root","currentDefaults","isObjectLike","baseGetTag","proto","getPrototype","Ctor","constructor","ObjProto","hasOwn","isInteger","Number","isFinite","Math","floor","Array","silent","expectedType","typeToCheck","valid","oldWarn","namePrefix","some","map","join","getNativeType","VueTypes","sensibleDefaults","Boolean","bool","String","string","number","array","object","integer","extend","props","descriptor","validate","getter","configurable","ret","args","custom","validatorFn","warnMsg","TypeError","oneOf","arr","msg","allowedTypes","reduce","v","indexOf","push","length","instanceOf","instanceConstructor","oneOfType","hasCustomValidators","nativeChecks","concat","typesStr","arrayOf","values","every","objectOf","keys","key","shape","requiredKeys","filter","valueKeys","req","_this","_vueTypes_isLoose","set","utils"],"mappings":"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"}